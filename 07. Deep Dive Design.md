- Purpose
	- The purpose of the deep dive section is to demonstrate to the interviewer that you can identify areas that could be problematic—known as bottlenecks—and develop potential solutions and trade-offs to address those issues. In addition, the topics you bring up and how you frame your proposed solution will be telling about your maturity as an engineer.
- How to Approach Deep Dive Design
	- The System Design Interview Golden Question ---- What is the problem I am trying to solve?
	- If there’s one piece of advice we wish people would take, it would be to consistently ask yourself the question, “What is the problem I am trying to solve?” Unfortunately, most candidates are too solution-oriented, and they jump into solutions instead of thinking about the problem they’re trying to solve. 
	- Being solution-oriented is most likely due to people reading blogs and tech talks from well-known companies and feeling obligated to retell the same level of difficulty of design in an interview to impress the interviewer. But instead, most seasoned interviewers are sitting there wondering why you’re proposing a particular solution without any basis.
	- This advice applies to real-life work as well. You’re not going to propose adding some cache cluster in front of your source of truth database to the senior engineer because you read it from a blog. It needs to make sense, and the trade-offs need to be well articulated, so the team knows the consequences of implementing the design. This approach should apply to system design interviews as well.
- Situation-1
	- You’ve just finished the API, high-level diagram, data structure, and schema to satisfy the requirement to match riders with drivers and have finished walking through the APIs with the interviewer. - Refer previous notes for diagram.
	- Don’t Do This
		- I would add a cache cluster in front of the driver location table, and I would shard the queue and the driver locations table because we have hundreds of millions of users, and we need to scale.”
	- Do This
		- Ok, let me think about areas that could potentially need to scale. Let’s start with the drivers’ location table. Let me calculate the QPS to see if it needs to scale.
		- The candidate does some back-of-the-envelope math calculations and comes up with 500k QPS to update_location API call.
		- Now, we have a problem with 500k QPS, and each database from my experience can handle 20k-30k QPS at best. We have a bottleneck problem. 
		- Proceed to talk about the solutions, trade-offs, and recommend a final solution.”
	- Analysis
		- In the Don’t section, it’s not even clear what the candidate is trying to solve. What if QPS isn’t an issue? Why are we assuming it to be an issue without a justification? In the Do section, the candidate identified a specific problem and proposed a solution. Solutions like telling the client to lower the update frequency can be an excellent scalability solution, even though it’s not “a hard distributed systems concept.”
- How to Come Up with Discussion Points
	- Hopefully, you would’ve already made some discussion point lists by this time from the API, high-level diagram, and schema section. For each discussion point, remember to think about the golden question, “What is the problem I am trying to solve?”
	- The good news is that you are the one coming up with the bottlenecks for the most part! In a system design interview, unless the interviewer tells you so, there’s no monitoring dashboard, product manager, or real customers to tell you what the query patterns are. So you can take advantage of this situation by coming up with problems and bottlenecks where you will shine. Just remember, it still needs to be relevant to the core of the problem.
	- Let’s say you are an expert in dealing with thundering herd problems and you’re working on a ridesharing service; you can set yourself for success by coming up with real-life scenarios where a thundering herd happens for ridesharing service. Then you can easily proceed to propose solutions for the thundering problem.”
- Advice
	- Come up with problem scenarios and bottlenecks that will set you up for success. The magic formula for success is:
		- Step 1: Identify a bottleneck
		- Step 2: Come up with options
		- Step 3: Talk about the trade offs
		- Step 4: Pick one solution
		- Step 5: Active discussion with interviewer
		- Step 6: Go to step 1
	- The more critical bottleneck you identify, the better it will look. Of course, your justifications from step 2 to step 4 will matter too, but if you identify irrelevant or non-critical bottlenecks, it won’t be as impressive.
- Situation-2
	- You’ve just finished the API, high-level diagram, data structure, and schema to satisfy the requirement to match riders with drivers, and have finished walking through the APIs with the interviewer. You’re looking for discussion points.
	- Do This
		- Take a look at the diagram you have so far. As an example, you suspect you might need a queue to take in the rider requests. You can set yourself up for success by claiming:
		- “Well, I am worried about thundering herd situations where there will be bursts of requests during rush hours and one-off events such as celebrity concerts where everybody leaves the venue at the same time. So I want to ensure the service won’t go down during such events.”
		- “Let me calculate what kind of QPS we need to support the driver location store. Perhaps we can consider turning it into a cache since we discussed that durability for location isn’t that important. Let me go over the options. Does that sound good?”
- Sometimes candidates still have difficulty coming up with interesting discussion points because they’re nervous or just don’t have the relevant industry experience to have that kind of intuition. So below are some frameworks that may help trigger some ideas. In the following list, we won’t talk about the solutions to the problem yet. Instead, the focus is on identifying important problems and discussion points.
	- API and Interprocess Calls
		- When you have a high-level diagram, there will be boxes and arrows. For the arrows, it’s usually an API or interprocess call. For each interprocess call, there could potentially be interesting discussion points.”
		- Latency
			- With your high-level diagram, look at your end-user API and think to yourself if there’s a query pattern where a discussion about latency is interesting. For example, in system design questions like typeahead, latency is critical. If you want to achieve 10 ms for p95, the network round trip in addition to a disk seek is likely not going to cut it. On the other hand, some questions like placing an airline ticket where the latency isn’t as big of a deal. Not everything needs to have low latency. You should build a product intuition around that and confirm with the interviewer.
		- High QPS
			- Any components like servers, queue, cache, database, etc., can break if the QPS is too high. Discussing QPS is the right time to do back-of-the-envelope calculations to identify if QPS is an actual problem. There are some ballpark numbers in Appendix 2: Capacity Number to help define that. After you identify QPS as a problem, you can think of possible solutions to resolve the issue, and there are many creative ways to tackle it.
		- Bursty of the API / Thundering Herd
			- If the world runs predictably and uniformly, it should be much easier to predict capacity and design. However, there are always user stories in real-life patterns that may lead to a sudden influx of requests and break the system down. For example, when a celebrity starts a live Facebook feed, people rush to watch the stream. When people finish a concert, people are requesting rides at the same time at the same place. When breaking news happens, tweeters are tweeting about the breaking news event. So, for the system design question you’re given, try to come up with a user story as an avenue to talk about scalability when such a thundering herd event happens.
		- Slow, Low Bandwidth, Congested Network
			- When you look at the arrow between the end-user and the system, think about the network. Companies like Facebook are trying to target the whole earth to every user. The end-users may have poor bandwidth due to various reasons in areas with poor services. For example, poor bandwidth can make photo uploading for Instagram challenging due to insufficient bandwidth. Think about some technical solutions and product requirement compromises that you can make to improve the end-user experience.
		- Query Optimization
			- Until you finish API, high-level diagram, and schema, you probably only came up with a happy case API that satisfies the requirement, and for most users, it will most likely work. However, we would like to bring a good user experience to all the users. So, take a look at your end-user API and internal RPC calls for the input, the output, and the API calling patterns.
			- For input, can you reduce the size the client passes to the server? For example, if it’s a huge file, can you just pass a chunk instead? For the output, are you able to reduce the amount of data passed back? For News Feed, instead of fetching for all the feeds, are you able to paginate it? For the end-user queries, are you able to reduce the number of API calls? Even if your design is already sound, letting the interviewer know that you’re thinking about query optimization will give a positive signal.
	- Micro Services, Queue, and Databases
		- On top of your high-level diagram, your arrows are boxes and diagrams that represent microservices, queue, load balancer, databases, etc. Take a look at each of those components and ask yourself some of the following questions.
		- Failure Scenario
			- When considering a component to discuss, think about what happens if that component fails and how the failure impacts your non-functional requirements. Think about partial failures and complete failures and the implications and consequences. Finally, think of creative and technical solutions to solve the failure scenarios.
			- For example, to design a ridesharing service, you need to store the driver’s location, but what if the driver location storage is down? What would be the impact on customers? Are they still able to retrieve for a ride, or will they be matched with a less optimal ride?
			- Another example is what happens if a queue worker processes and commits a finished job but fails to acknowledge the queue. Another worker may end up picking that job again, leading to a double run. It’s essential to think about the implication of double run here and the impact on the end-user.
		- High Amount of Data
			- For storage-related components like in-memory stores on an app server, cache, and databases, think about the current query pattern to the store and what the store is storing. Think about whether the current query pattern will lead to too much data and inefficiency for future queries. Will the current pattern lead to out-of-memory issues to the app servers and the cache? Storage bottleneck is another opportunity for back-of-the-envelope calculations to see if the current storage pattern is sustainable and what kind of optimization solutions you can come up with.
		- Dig Deeper to Identify More Areas of Interest
			- Take a look at the high-level diagram and think about an area that you can deep dive into and discuss ever further. As you dig into an area, it may lead to other opportunities for problem discussions relevant to the question.
			- For example, if you were to design a notification service, you will likely have a bi-directional WebSocket connection to push from the server to the client. Most candidates will draw a bi-directional arrow between the client and the server and conclude there. WebSocket is an opportunity to dig deeper into how managing a WebSocket works and how some users may not get notified if a WebSocket server goes down. You should discuss with the interviewer if that’s an acceptable user experience.
		- Design Choices
			- As you look at the high-level diagram, you might run into situations where you have to provide more details on top of the box in the flow diagram. As you explain, you might find yourself having to choose between design choices. For example, if you’re looking at the database, you can think of the options and which one is the best for this question. If you’re looking at a queue, you can talk about what kind of queue you would like to use for this question. When you dig into possible solutions, focus on the fundamentals of the technologies, not just buzzwords. Focus on how the fundamentals impact the user experience. This requires some technical knowledge which we will cover in the toolbox chapter.
	- Detailed Algorithm, Data Structure, and Schema
		- Sometimes as you’re going through the high-level diagram, you may have only one algorithm, one data structure, and one schema. Here’s an opportunity to optimize the algorithm, data structure, and schema and develop more design choices. The question you are asking yourself is, “Do I have alternative solutions that would make the current system even better?”
		- For example, to design a ridesharing service and store the driver location, you might have a table that keeps on appending a new driver location where you insert one record every time there’s a location update. Take a look at that and think if there is optimization you can make to that table. Are you able to store less? Are you able to optimize the lookup query?
	- Concurrency
		- Concurrency is a topic that most candidates fear, and mastery in this area will set you apart from most of the candidates. Usually, when you draw the high-level diagram, there will be shared resources, but what if the requests are accessing the same resources simultaneously? What would be the implication to the end-user?
		- You will get some credit from identifying the concurrency issue of your design, and it’s even better if you can come up with a reasonable solution to the problem. So take a look at your high-level diagram and see if there are resources that are accessed at the same time by different clients. And even if the resource belongs to the same user, there can still be concurrency problems when there are multiple sessions.
		      ![Screenshot 2022-08-07 at 11 21 35 AM](https://user-images.githubusercontent.com/49789867/183277444-434978fe-716a-4b4f-9b22-e70026df4463.png)
		- You will get some credit from identifying the concurrency issue of your design, and it’s even better if you can come up with a reasonable solution to the problem. So take a look at your high-level diagram and see if there are resources that are accessed at the same time by different clients. And even if the resource belongs to the same user, there can still be concurrency problems when there are multiple sessions.
	- Security Considerations
		- Candidates often overlook security discussions since most engineers think of them as something only for security engineers. In a system design interview, while the interviewer may ask you about basic concepts such as Transport Layer Security (TLS) and tokens as trivia questions, they shouldn’t focus on the security discussion unless they’re significant to the requirements.
		- For example, you should discuss the implications of a man-in-the-middle or malicious user attack for your design. For example, you designed an API for the ticket booking system with book_ticket(user_id, ticket_id). What if the end-user tries to book many tickets and cancels them later on, to lock up the tickets maliciously? What would be the implication, and more importantly, how would you deal with it?
		- For a payment system like Venmo, if you came up with the API transfer_money(from_user_id, to_user_id, amount), what if the user specifies an amount they don’t have? What if the user specifies to_user_id as themself and from_user_id as another person?
		- The answer may just be having some sort of token verification and business validation, but the point is to let the interviewer know that you have the awareness to bring up related security topics, and you get credit for doing so. You can expect feedback like, “The candidate brings up relevant security topics and provides reasonable solutions to them. Most candidates don’t even think about security. I can trust the candidate to design safe and reliable APIs.”
