- **Definition**
	- A database is an organized collection of data that is stored by the application for durability.
- **Purpose**
	- Most system design interviews will require permanent storage to persist data and allow other services to read the data. Therefore, choosing the right database is important to the performance of your architecture. In a system design interview, the interviewer will sometimes be looking for your ability to justify the database of your choice based on fundamentals. 
- **How Do I Choose a Database?**
	- Choosing a database is difficult. In practice, engineers could spend weeks making that decision because it is difficult to migrate once the database is in place. In addition, the database is a very complex space with a lot of competing products and complex internals. Therefore, you need to strike the right balance between going too shallow and too deep.
	- In a system design interview, we encourage you to reflect on your design patterns and choose a database that mostly meets the needs of the design. Then, you should give a list of reasons that make that database a stronger choice than the other ones. Justifications like, “I will use Cassandra because it scales well,” are too hand-wavy because other databases also scale well.
	- CAP theorem is a generalized term to help understand distributed databases.
		- C stands for consistency, which means all the databases see the same data at the same time.
		- A stands for availability, which means the database is up to serve traffic.
		- P stands for partition tolerance, which means the system continues to work if there’s a network issue between databases.
		- CAP theorem states you can only have two of the three.
			- AC: Means there’s no partition with a single machine.
			- CP: Means if there’s a network issue between the databases, the request fails in favor of consistency.
			- AP: Means if there’s a network issue between the databases, the request continues to work in favor of availability.
	- **Understanding AP with Cassandra**
		- Now let’s also look at how a system compromises on Consistency. For this, we will look at the Cassandra database which is called a highly available database.
		- Cassandra is a peer-to-peer system. It consists of multiple nodes in the system. And each node can accept a read or write request from the user. Cassandra maintains multiple replicas of data in separate nodes. This gives it a masterless node architecture where there are multiple points of failure instead of a single point.
		- The replication factor determines the number of replicas of data. If the replication factor is 3, then we will replicate the data in three nodes in a clockwise manner.
		- A situation can occur where a partition occurs and the replica does not get an updated copy of the data. In such a situation the replica nodes will still be available to the user but the data will be inconsistent. However, Cassandra also provides eventual consistency. Meaning, all updates will reach all the replicas eventually. But in the meantime, it allows divergent versions of the same data to exist temporarily. Until we update them to the consistent state.
		- Therefore, by allowing nodes to be available throughout and allowing temporarily inconsistent data to existing in the system, Cassandra is an AP database that compromises on consistency.
			<img width="531" alt="Screenshot 2022-09-02 at 12 34 47 PM" src="https://user-images.githubusercontent.com/49789867/188078765-30cba568-acf1-43f1-93a9-7a3130097e32.png">
	- **Understanding CP with MongoDB**
		- MongoDB is a NoSQL database that stores data in one or more Primary nodes in the form of JSON files. Each Primary node has multiple replica sets that update themselves asynchronously using the operation log file of their respective primary node. The replica set nodes in the system send a heartbeat (ping) to every other node to keep track if other replicas or primary nodes are alive or dead. If no heartbeat is received within 10 seconds, then that node is marked as inaccessible.
		- If a Primary node becomes inaccessible, then one of the secondary nodes needs to become the primary node. Till a new primary is elected from amongst the secondary nodes, the system remains unavailable to the user to make any new write query. Therefore, the MongoDB system behaves as a Consistent system and compromises on Availability during a partition.
		- Choosing a database is hard. So many people use the CAP theorem to justify a database. You might need to dig deeper than just the CAP theorem in an interview. For example, if you say MySQL is a “CP” database and Cassandra is an “AP” database, what happens if you read from a follower of a MySQL with asynchronous replication? It’s not really “CP” anymore. We think the best way to choose a database is to understand a list of categories of databases and what they are good at. That way, in an interview, you’re able to choose one that’s the most appropriate for your use case.
		- Sometimes the interviewer may dig a bit deeper into the internals. For example, if you claim Cassandra is an “AP” system, they may ask you why Cassandra is an “AP” system. If you claim HBase is good with chat applications, the interviewer may ask you why not MySQL or MongoDB. These are fair questions that may come up, so you should dig deeper into each of the databases to help you with that.
		- Databases are very complicated and are often not an apples-to-apples comparison. In an interview, it’s really about if they make sense, and how you sell your justifications to the interviewer. Databases exist to solve a particular problem, and the better you can articulate how a database solves your problem, the better you’ll perform.
			<img width="765" alt="Screenshot 2022-09-02 at 12 34 21 PM" src="https://user-images.githubusercontent.com/49789867/188078837-ed85eef9-9bb7-4a72-9dda-ec43fc5cc38e.png">
- **Types of Databases**
	- **Relational Database**
		- In relational databases, it is easy to represent the entities as tables and define the relationship between them. It supports transactions to write to one or many entities and supports simple to complex read queries. You’re able to add in an ad-hoc index to improve the read performance at the expense of write performance. Also, if you have multiple entities with shared attributes, you can fetch results with a joined or unioned table. Also, it supports updates for a record well. Some databases are append-only.
		- However, it doesn’t mean a relational database is efficient at all the queries. So you need to think about the query you’re making and have some intuition on whether it’ll be efficient for the relational database.
		- Don’t fall into the trap of saying relational databases don’t scale. Relational databases do scale, and all big companies use them. However, relational databases may not scale for particular use cases, and there are better options, and you should be clear about why. For example, if the use case is metrics collection where there’s a high write ingestion without the need to join tables and is append-only, a relational database probably “doesn’t scale” for that use case.
		- MySQL, Postgres.
	- **Document Store**
		- A document database is a type of nonrelational database that is designed to store and query data as JSON-like documents.
		- Document databases make it easier for developers to store and query data in a database by using the same document-model format they use in their application code. 
		- The flexible, semistructured, and hierarchical nature of documents and document databases allows them to evolve with applications’ needs. The document model works well with use cases such as catalogs, user profiles, and content management systems where each document is unique and evolves over time. Document databases enable flexible indexing, powerful ad hoc queries, and analytics over collections of documents.
		- Use cases
			- Content management
				- A document database is a great choice for content management applications such as blogs and video platforms. With a document database, each entity that the application tracks can be stored as a single document. The document database is more intuitive for a developer to update an application as the requirements evolve. In addition, if the data model needs to change, only the affected documents need to be updated. No schema update is required and no database downtime is necessary to make the changes. 
			- Catalogs
				- Document databases are efficient and effective for storing catalog information. For example, in an e-commerce application, different products usually have different numbers of attributes. Managing thousands of attributes in relational databases is inefficient, and the reading performance is affected. Using a document database, each product’s attributes can be described in a single document for easy management and faster reading speed. Changing the attributes of one product won’t affect others.
		- MongoDB, Amazon DocumentDB
	- **Columnar Store**
		- The columnar store has a schema that looks the same as a traditional relational database. However, columnar stores are more optimized for OLAP queries to fetch data in a column fashion. For example, assume you have a table for time_stamp | metrics_value. Then, you might query for all the metrics_value from time_0 to time_1. This query pattern is good for analytics databases and time-series databases which have a lot of overlaps.
		- For a time-series database that stores its data in a columnar fashion, writes happen more frequently than read. Update to any record is rare since most are append-only. When deletion happens, the deletions happen in batches instead of an ad-hoc operation like in a relational database.
		- In a system design interview, a good candidate for a columnar store would be an analytics dashboard. Most analytics dashboards show some sort of graph with an x-axis and y-axis. And for each graph, you will want to fetch a series of data to be displayed on the dashboard. However, this significantly depends on the dashboard query, so make sure you understand the datas on the dashboard graphs before committing to a columnar store.
		- InfluxDB
	- **Object Store**
		- When you’re designing to store objects like photos, videos, file documents, etc. You need to handle objects differently due to the potential amount of data taking up the bandwidth and storage. Blob stores are immutable. Once stored, you can not change the file. You can change by inserting or appending new data.
		- If you try to store a blob in a relational database, you will take up a lot of memory on the table and worsen the performance of the regular OLTP transactions.
		- use case:
			- Design Instagram: For Instagram, assuming you’re storing videos and images for each post, you will want to store the videos and images in a blob store.
			- Log Storage: When you need to store logs, you can consider using an object store to store the log dump.
			- File Storage: For any files that you need to store, you can use object storage. For example, if the interviewer asks you to design a system that takes in a pdf of CSV and has a data pipeline to process the files, you may want to store the pdf or CSV in the object store and have some pipeline pull from the object store to be processed.
		- Amazon S3.
	- **Wide Column Store**
		- Wide column store works well when there’s a lot of data collected at a very high write speed. The read performance is also great when the read targets a row key that is defined.
		- A wide column store isn’t good when you need to do joins across tables. Although a wide column store doesn’t support ad-hoc modifications to a persisted value, the read query does well when it is append-only.
		- use case
			- Design Facebook Chat: The chat messages usually come into the system with a high write throughput and typically appends only. On read, it’s usually reading a list of messages for a chat_id.
			- Design Metrics Collection: For the metrics collection type of question, the write throughput is usually very high because metrics are generally assumed to omit data constantly. Your system has to deal with the high rate of data collection. The read query targets a group of specific device_id’s that omit the metrics without a complex query.
		- Example of wide column store based on a chat system
			- Terminology:
				- Row: Collection of column families
				- Column Family: Collection of columns. Column families are loaded together and stored together.
				- Column: Consists of name, value, and timestamp. When the database creates a value, it also creates a new version timestamp.
			- Schema:
				- Row: chat_id
				- Column Family: message
				- Columns: message_id, message_text, author_id, created_time
				- And you cluster order by created_time which means the columns are sorted by created_time since the typical access pattern of chat is to fetch by timestamp intervals.
			- From the outside, the term “wide column” is just the schema. However, it’s coupled with some popular databases like Big Table, HBase, and Cassandra. Internally, those wide column databases use LSM indexing strategy, which is more optimized for writes. Also, within a column family, data are stored together physically next to each other for a given row. For example, for a chat application mentioned above, the data might look like the following for a chat_id:
				- message_id: 1, message_text: “hello” author_id: 1, created_time: t1
				- message_id: 2, message_text: “sup” author_id: 2, created_time: t2
				- message_id: 3, message_text: “nm” author_id: 1, created_time: t3
			- Since these records are physically next to each other, it’s much faster to query.
		- Replication Strategy:
			- Even within the wide column database type, there are different replication strategies. HBase uses a leader-follower replication, whereas Cassandra uses a leaderless replication. Because of the leaderless replication, Cassandra has to deal with conflicting writes with lower consistency than HBase. In an interview, you can pick one of the two based on your design requirement, and it’s worth talking about your strategy on conflict resolution if you decide to use a leaderless solution like Cassandra.
		- Examples --- Big Table, HBase, Cassandra.
	- **Reverse Index Store:**
		- When designing for a search-related problem where you need to build reverse indexes, you can consider a reverse index store.
			- search(search_query)→[item]
			- search(term)→[item]
		- Internally a reverse index is just a key-value store where the key is the term token, and the value is a posting list. A posting list is an abstract term for the item you’re searching for. Here’s a canonical example of a search problem. 
			- Imagine you have two documents:
				- Document 1: “my dog house”
				- Document 2: “their dog”
			- The reverse index is going to be:
				- “dog”→[doc1, doc2]
				- “house”→[doc1]
				- “my”→[doc1]
				- “their”→[doc2]”
			- When a search query “dog OR house” comes in, we can take the union of “dog” and “house” and combine the result, which is doc1 and doc2. When a search query “dog AND house” comes in, we can take the intersection of “dog” and “house” and combine the result, which is just doc1.
		- Examples - Elastic Search, Lucene.
	- **Zookeper**
		- ZooKeeper is more than just a store. But it’s worth talking about storage since ZooKeeper is commonly used to store configurations and name registries. In addition, you can use ZooKeeper because it provides strong consistency with good fault tolerance to the end-user
		- In a system design interview, here are some places where A ZooKeeper may be used:
			- Shard Manager
				- You will have a list of physical nodes you need to call for a given logical shard. You can store this information in ZooKeeper. Knowing this might come in handy if the interviewer asks you for more detail about your sharding architecture.
			- Configuration Manager
				- If you have an application that needs to read a global configuration service that needs to be strongly consistent, you can consider ZooKeeper.
			- Leader Election
				- When you have a chosen leader-follower replication for your database when you’re discussing the fault tolerance of your database, you can mention that ZooKeeper will monitor the health of your leader and follower nodes and perform an election to elect a new leader.
