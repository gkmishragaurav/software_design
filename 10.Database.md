- **Definition**
	- A database is an organized collection of data that is stored by the application for durability.
- **Purpose**
	- Most system design interviews will require permanent storage to persist data and allow other services to read the data. Therefore, choosing the right database is important to the performance of your architecture. In a system design interview, the interviewer will sometimes be looking for your ability to justify the database of your choice based on fundamentals. 
- **How Do I Choose a Database?**
	- Choosing a database is difficult. In practice, engineers could spend weeks making that decision because it is difficult to migrate once the database is in place. In addition, the database is a very complex space with a lot of competing products and complex internals. Therefore, you need to strike the right balance between going too shallow and too deep.
	- In a system design interview, we encourage you to reflect on your design patterns and choose a database that mostly meets the needs of the design. Then, you should give a list of reasons that make that database a stronger choice than the other ones. Justifications like, “I will use Cassandra because it scales well,” are too hand-wavy because other databases also scale well.
	- CAP theorem is a generalized term to help understand distributed databases.
		- C stands for consistency, which means all the databases see the same data at the same time.
		- A stands for availability, which means the database is up to serve traffic.
		- P stands for partition tolerance, which means the system continues to work if there’s a network issue between databases.
		- CAP theorem states you can only have two of the three.
			- AC: Means there’s no partition with a single machine.
			- CP: Means if there’s a network issue between the databases, the request fails in favor of consistency.
			- AP: Means if there’s a network issue between the databases, the request continues to work in favor of availability.
	- **Understanding AP with Cassandra**
		- Now let’s also look at how a system compromises on Consistency. For this, we will look at the Cassandra database which is called a highly available database.
		- Cassandra is a peer-to-peer system. It consists of multiple nodes in the system. And each node can accept a read or write request from the user. Cassandra maintains multiple replicas of data in separate nodes. This gives it a masterless node architecture where there are multiple points of failure instead of a single point.
		- The replication factor determines the number of replicas of data. If the replication factor is 3, then we will replicate the data in three nodes in a clockwise manner.
		- A situation can occur where a partition occurs and the replica does not get an updated copy of the data. In such a situation the replica nodes will still be available to the user but the data will be inconsistent. However, Cassandra also provides eventual consistency. Meaning, all updates will reach all the replicas eventually. But in the meantime, it allows divergent versions of the same data to exist temporarily. Until we update them to the consistent state.
		- Therefore, by allowing nodes to be available throughout and allowing temporarily inconsistent data to existing in the system, Cassandra is an AP database that compromises on consistency.
			<img width="531" alt="Screenshot 2022-09-02 at 12 34 47 PM" src="https://user-images.githubusercontent.com/49789867/188078765-30cba568-acf1-43f1-93a9-7a3130097e32.png">
	- **Understanding CP with MongoDB**
		- MongoDB is a NoSQL database that stores data in one or more Primary nodes in the form of JSON files. Each Primary node has multiple replica sets that update themselves asynchronously using the operation log file of their respective primary node. The replica set nodes in the system send a heartbeat (ping) to every other node to keep track if other replicas or primary nodes are alive or dead. If no heartbeat is received within 10 seconds, then that node is marked as inaccessible.
		- If a Primary node becomes inaccessible, then one of the secondary nodes needs to become the primary node. Till a new primary is elected from amongst the secondary nodes, the system remains unavailable to the user to make any new write query. Therefore, the MongoDB system behaves as a Consistent system and compromises on Availability during a partition.
		- Choosing a database is hard. So many people use the CAP theorem to justify a database. You might need to dig deeper than just the CAP theorem in an interview. For example, if you say MySQL is a “CP” database and Cassandra is an “AP” database, what happens if you read from a follower of a MySQL with asynchronous replication? It’s not really “CP” anymore. We think the best way to choose a database is to understand a list of categories of databases and what they are good at. That way, in an interview, you’re able to choose one that’s the most appropriate for your use case.
		- Sometimes the interviewer may dig a bit deeper into the internals. For example, if you claim Cassandra is an “AP” system, they may ask you why Cassandra is an “AP” system. If you claim HBase is good with chat applications, the interviewer may ask you why not MySQL or MongoDB. These are fair questions that may come up, so you should dig deeper into each of the databases to help you with that.
		- Databases are very complicated and are often not an apples-to-apples comparison. In an interview, it’s really about if they make sense, and how you sell your justifications to the interviewer. Databases exist to solve a particular problem, and the better you can articulate how a database solves your problem, the better you’ll perform.
			<img width="765" alt="Screenshot 2022-09-02 at 12 34 21 PM" src="https://user-images.githubusercontent.com/49789867/188078837-ed85eef9-9bb7-4a72-9dda-ec43fc5cc38e.png">
- **Types of Databases**
	- **Relational Database**
		- In relational databases, it is easy to represent the entities as tables and define the relationship between them. It supports transactions to write to one or many entities and supports simple to complex read queries. You’re able to add in an ad-hoc index to improve the read performance at the expense of write performance. Also, if you have multiple entities with shared attributes, you can fetch results with a joined or unioned table. Also, it supports updates for a record well. Some databases are append-only.
		- However, it doesn’t mean a relational database is efficient at all the queries. So you need to think about the query you’re making and have some intuition on whether it’ll be efficient for the relational database.
		- Don’t fall into the trap of saying relational databases don’t scale. Relational databases do scale, and all big companies use them. However, relational databases may not scale for particular use cases, and there are better options, and you should be clear about why. For example, if the use case is metrics collection where there’s a high write ingestion without the need to join tables and is append-only, a relational database probably “doesn’t scale” for that use case.
		- MySQL, Postgres.
	- **Document Store**
		- A document database is a type of nonrelational database that is designed to store and query data as JSON-like documents.
		- Document databases make it easier for developers to store and query data in a database by using the same document-model format they use in their application code. 
		- The flexible, semistructured, and hierarchical nature of documents and document databases allows them to evolve with applications’ needs. The document model works well with use cases such as catalogs, user profiles, and content management systems where each document is unique and evolves over time. Document databases enable flexible indexing, powerful ad hoc queries, and analytics over collections of documents.
		- Use cases
			- Content management
				- A document database is a great choice for content management applications such as blogs and video platforms. With a document database, each entity that the application tracks can be stored as a single document. The document database is more intuitive for a developer to update an application as the requirements evolve. In addition, if the data model needs to change, only the affected documents need to be updated. No schema update is required and no database downtime is necessary to make the changes. 
			- Catalogs
				- Document databases are efficient and effective for storing catalog information. For example, in an e-commerce application, different products usually have different numbers of attributes. Managing thousands of attributes in relational databases is inefficient, and the reading performance is affected. Using a document database, each product’s attributes can be described in a single document for easy management and faster reading speed. Changing the attributes of one product won’t affect others.
		- MongoDB, Amazon DocumentDB
	- **Columnar Store**
		- The columnar store has a schema that looks the same as a traditional relational database. However, columnar stores are more optimized for OLAP queries to fetch data in a column fashion. For example, assume you have a table for time_stamp | metrics_value. Then, you might query for all the metrics_value from time_0 to time_1. This query pattern is good for analytics databases and time-series databases which have a lot of overlaps.
		- For a time-series database that stores its data in a columnar fashion, writes happen more frequently than read. Update to any record is rare since most are append-only. When deletion happens, the deletions happen in batches instead of an ad-hoc operation like in a relational database.
		- In a system design interview, a good candidate for a columnar store would be an analytics dashboard. Most analytics dashboards show some sort of graph with an x-axis and y-axis. And for each graph, you will want to fetch a series of data to be displayed on the dashboard. However, this significantly depends on the dashboard query, so make sure you understand the datas on the dashboard graphs before committing to a columnar store.
		- InfluxDB
	- **Object Store**
		- When you’re designing to store objects like photos, videos, file documents, etc. You need to handle objects differently due to the potential amount of data taking up the bandwidth and storage. Blob stores are immutable. Once stored, you can not change the file. You can change by inserting or appending new data.
		- If you try to store a blob in a relational database, you will take up a lot of memory on the table and worsen the performance of the regular OLTP transactions.
		- use case:
			- Design Instagram: For Instagram, assuming you’re storing videos and images for each post, you will want to store the videos and images in a blob store.
			- Log Storage: When you need to store logs, you can consider using an object store to store the log dump.
			- File Storage: For any files that you need to store, you can use object storage. For example, if the interviewer asks you to design a system that takes in a pdf of CSV and has a data pipeline to process the files, you may want to store the pdf or CSV in the object store and have some pipeline pull from the object store to be processed.
		- Amazon S3.
	- **Zookeper**
		- ZooKeeper is more than just a store. But it’s worth talking about storage since ZooKeeper is commonly used to store configurations and name registries. In addition, you can use ZooKeeper because it provides strong consistency with good fault tolerance to the end-user
		- In a system design interview, here are some places where A ZooKeeper may be used:
			- Shard Manager
				- You will have a list of physical nodes you need to call for a given logical shard. You can store this information in ZooKeeper. Knowing this might come in handy if the interviewer asks you for more detail about your sharding architecture.
			- Configuration Manager
				- If you have an application that needs to read a global configuration service that needs to be strongly consistent, you can consider ZooKeeper.
			- Leader Election
				- When you have a chosen leader-follower replication for your database when you’re discussing the fault tolerance of your database, you can mention that ZooKeeper will monitor the health of your leader and follower nodes and perform an election to elect a new leader.
