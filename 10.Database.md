- **Definition**
	- A database is an organized collection of data that is stored by the application for durability.
- **Purpose**
	Most system design interviews will require permanent storage to persist data and allow other services to read the data. Therefore, choosing the right database is important to the performance of your architecture. In a system design interview, the interviewer will sometimes be looking for your ability to justify the database of your choice based on fundamentals. 
- **How Do I Choose a Database?**
	- Choosing a database is difficult. In practice, engineers could spend weeks making that decision because it is difficult to migrate once the database is in place. In addition, the database is a very complex space with a lot of competing products and complex internals. Therefore, you need to strike the right balance between going too shallow and too deep.
	- In a system design interview, we encourage you to reflect on your design patterns and choose a database that mostly meets the needs of the design. Then, you should give a list of reasons that make that database a stronger choice than the other ones. Justifications like, “I will use Cassandra because it scales well,” are too hand-wavy because other databases also scale well.
	- CAP theorem is a generalized term to help understand distributed databases.
		- C stands for consistency, which means all the databases see the same data at the same time.
		- A stands for availability, which means the database is up to serve traffic.
		- P stands for partition tolerance, which means the system continues to work if there’s a network issue between databases.
		- CAP theorem states you can only have two of the three.
			- AC: Means there’s no partition with a single machine.
			- CP: Means if there’s a network issue between the databases, the request fails in favor of consistency.
			- AP: Means if there’s a network issue between the databases, the request continues to work in favor of availability.
	- Choosing a database is hard. So many people use the CAP theorem to justify a database. You might need to dig deeper than just the CAP theorem in an interview. For example, if you say MySQL is a “CP” database and Cassandra is an “AP” database, what happens if you read from a follower of a MySQL with asynchronous replication? It’s not really “CP” anymore. We think the best way to choose a database is to understand a list of categories of databases and what they are good at. That way, in an interview, you’re able to choose one that’s the most appropriate for your use case.
	- Sometimes the interviewer may dig a bit deeper into the internals. For example, if you claim Cassandra is an “AP” system, they may ask you why Cassandra is an “AP” system. If you claim HBase is good with chat applications, the interviewer may ask you why not MySQL or MongoDB. These are fair questions that may come up, so you should dig deeper into each of the databases to help you with that.
	- Databases are very complicated and are often not an apples-to-apples comparison. In an interview, it’s really about if they make sense, and how you sell your justifications to the interviewer. Databases exist to solve a particular problem, and the better you can articulate how a database solves your problem, the better you’ll perform.
- **Types of Databases**
	- Relational Database
		- In relational databases, it is easy to represent the entities as tables and define the relationship between them. It supports transactions to write to one or many entities and supports simple to complex read queries. You’re able to add in an ad-hoc index to improve the read performance at the expense of write performance. Also, if you have multiple entities with shared attributes, you can fetch results with a joined or unioned table. Also, it supports updates for a record well. Some databases are append-only.
		- However, it doesn’t mean a relational database is efficient at all the queries. So you need to think about the query you’re making and have some intuition on whether it’ll be efficient for the relational database.
		- Don’t fall into the trap of saying relational databases don’t scale. Relational databases do scale, and all big companies use them. However, relational databases may not scale for particular use cases, and there are better options, and you should be clear about why. For example, if the use case is metrics collection where there’s a high write ingestion without the need to join tables and is append-only, a relational database probably “doesn’t scale” for that use case.
		- MySQL, Postgres.
	- Document Store
		- You should use a document database if the data you are storing is unstructured and doesn’t fit well in a relational database. For example, if you’re storing a product catalog where the schema between each product catalog could differ significantly, creating a relational table with all the known columns may be wasteful, since the storage will be sparse. Documents can use formats such as JSON and XML, and if your data fits naturally to those representations, then it’s a good fit.
		- MongoDB
	- Columnar Store
		- The columnar store has a schema that looks the same as a traditional relational database. However, columnar stores are more optimized for OLAP queries to fetch data in a column fashion. For example, assume you have a table for time_stamp | metrics_value. Then, you might query for all the metrics_value from time_0 to time_1. This query pattern is good for analytics databases and time-series databases which have a lot of overlaps.
		- For a time-series database that stores its data in a columnar fashion, writes happen more frequently than read. Update to any record is rare since most are append-only. When deletion happens, the deletions happen in batches instead of an ad-hoc operation like in a relational database.
		- In a system design interview, a good candidate for a columnar store would be an analytics dashboard. Most analytics dashboards show some sort of graph with an x-axis and y-axis. And for each graph, you will want to fetch a series of data to be displayed on the dashboard. However, this significantly depends on the dashboard query, so make sure you understand the datas on the dashboard graphs before committing to a columnar store.
		- InfluxDB
	- Object Store
		- When you’re designing to store objects like photos, videos, file documents, etc. You need to handle objects differently due to the potential amount of data taking up the bandwidth and storage. Blob stores are immutable. Once stored, you can not change the file. You can change by inserting or appending new data.
		- If you try to store a blob in a relational database, you will take up a lot of memory on the table and worsen the performance of the regular OLTP transactions.
		- Amazon S3.
	- Zookeper
		- ZooKeeper is more than just a store. But it’s worth talking about storage since ZooKeeper is commonly used to store configurations and name registries. In addition, you can use ZooKeeper because it provides strong consistency with good fault tolerance to the end-user
		- In a system design interview, here are some places where A ZooKeeper may be used:
			- Shard Manager
				- You will have a list of physical nodes you need to call for a given logical shard. You can store this information in ZooKeeper. Knowing this might come in handy if the interviewer asks you for more detail about your sharding architecture.
			- Configuration Manager
				- If you have an application that needs to read a global configuration service that needs to be strongly consistent, you can consider ZooKeeper.
			- Leader Election
				- When you have a chosen leader-follower replication for your database when you’re discussing the fault tolerance of your database, you can mention that ZooKeeper will monitor the health of your leader and follower nodes and perform an election to elect a new leader.
