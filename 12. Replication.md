- Definition
	- Replication is the process of copying data from a data source to other data sources. For example, imagine database A has records 1, 2, and 3. When database A finishes replicating to database B, database B will also have records 1, 2, and 3.
- Purpose and Examples
	- Before we get into the details of some of the replication strategies, it’s worth talking high-level on why replication is needed. We will use databases as examples, even though other data sources like cache or app servers can apply replication strategies as well.
	- Improve the Availability of the System
		- When one database is down, the system can use another database to serve the live traffic.
	- Improve the Durability of the System
		- When databases fail and break, there are replicated databases with the same data, so the data isn’t lost forever.
	- Improve the Latency of the System
		- The system can replicate databases to another data center or point of presence such that the data is closer to the user. By being physically closer to the user, there’s less distance the data has to travel to to reach the user.
	- Improve the Bandwidth of the System
		- When the data is far away from the user, it is more likely the bytes will need to travel through more networks and encounter a network that creates a bottleneck. Imagine placing a dinner delivery 1 mile away vs. 100 miles away. The delivery person needs to incur more time and a higher gas fee for 100 miles. That is true with CDNs as well when the origin server is further away from the user.
	- Improve the Throughput of the System
		- With replication, there will be more databases with the same data, and the system can handle more requests since there are more databases.
- Leader-Follower Replication
	- When the query writes to the leader in a leader-follower replication, the system will replicate to one or many followers. Read queries can happen on any of the databases. There are two types of replication: synchronous and asynchronous.
	- Synchronous Replication
		- For synchronous replication, the write query to the leader must wait for the leader and follower to commit before claiming the write query is successful.
		- The advantage of synchronous replication is the follower will have up-to-date data with the leader when the write query is successful.
		- The disadvantage of synchronous replication is that it is slow and relatively unavailable. Imagine you do synchronous replication to two followers. If either of the followers is located far away, the latency will be high and unpredictable. If either of the followers is unavailable, the write query will fail and lower the overall availability.
	- Asynchronous Replication
		- For asynchronous replication, once the write query is committed to the leader, it fires and forgets to replicate to the followers and commits the write. Because you no longer have to wait for the followers to commit, the write is faster and more available. Furthermore, if any of the followers fails, the write query is still successful.
		- The advantage of asynchronous replication is a faster transaction since you don’t need to wait for the follower to commit.
		- The disadvantage of doing so is inconsistent data between the leader and the followers. If I have a user querying any of the databases at any given time, I may get a different result due to replication lag. Replication lag means it takes time to copy a piece of data from the leader to the followers.
	- For Asynchronous Replication - take care following
		- Read Your Own Write
			- If you write to the leader and read from the follower, you may design a bad user experience where the user feels like they haven’t committed because the newest data has not made it to the follower yet.
		- Inconsistent Read from Different Read Replicas
			- You might get inconsistent results from different read replicas if you have a load balancer that round robins between read replicas. This might be acceptable for some applications but not for others.
	- Follower Failure
		- If the follower fails to respond, the system needs to detect the follower is faulty and stop forwarding requests to that follower. However, this may lead to a snowball effect if not careful. For example, if the followers are close to capacity, forwarding additional traffic to other followers may bring down more followers.
	- Leader Failure
		- If a leader fails to respond, nobody will be available to handle writes. If you’re designing an available system in a system design interview, you need to talk about handling writes when the leader fails. Once you’ve identified that the leader is down, you can either manually configure a follower to be the leader or perform a leader election using quorum. The downside to picking a new leader is that the process takes time. The system could be down for a couple of seconds or more because it takes time to determine a leader is down using timeouts and for a quorum election to take place. This delay might be unacceptable for some systems.
- Leader-Leader Replication
	- The problem with a single leader setup is that when the leader is down, nobody will be available to take writes until a new leader is available. In a leader-leader configuration, there will be multiple leader nodes to take writes. The system will replicate the data to each leader to keep them up to date. Each leader can still have follower replication for backup and reads.
	- The advantage of this approach is the writer will be more available since if one leader goes down, the other leader can take over. However, note that the performance will probably worsen because the new leader might be further away. Also, you have to deal with replication lag where the new leader might not have the most updated data. Another advantage is that if the leader is closer to a user, the latency will be faster than other leaders.
	- The disadvantage of this approach is the complexity of conflicting data. For example, if users are writing the same key to each of the leaders, while there are multiple ways to resolve the conflict and the solution depends on the application, there is additional complexity the engineers have to worry about. Similarly, if the leader goes down, a new leader has to be selected to take write.
- How to Pick a Replication Strategy
	- Now that we’ve covered a couple of replication strategies, we will go over some examples of applying this knowledge to a system design interview chapter. Whenever you’re dealing with data sources, it’s an opportunity for replication strategy. Replication strategy doesn’t have to apply to databases. It can apply to cache servers or app servers that have in-memory data structures. Generally speaking, you should list them out as options and think about the trade-offs using the knowledge above.
- What Should Be My Replication Factor?
	- Generally, the industry average is 3, but you should talk about the trade-off in an interview. More means more cost to maintain databases, and if it’s synchronous replication, it can lower the query performances. On the other hand, a lower count means a lower durability guarantee with fewer replicas as a backup.
