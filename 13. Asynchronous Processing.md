- Definition
	- Asynchronous processing is when a client executes something and doesn’t wait for that task to complete before moving onto something else.
- Purpose
	- The purpose of asynchronous processing is to offload the task at hand to a background processing such that the caller does not have to wait for the response of the task result. This leads to lower latency because the request processing doesn’t block the client.
- Synchronous and Asynchronous
	- Before going deeper into the advantages and disadvantages of asynchronous processing, it will be helpful to go over some examples of the difference between synchronous and asynchronous. Unfortunately, a lot of candidates get confused between the two. For an API call, synchronicity is concerning how much server work completion the client waits for before moving on to the next operation. In a synchronous call, the user waits for the task result, whereas in an asynchronous call, the user does not wait for the task result.
- Task Scope
	- The scope of the task is important here. Knowing how to differentiate the two will allow you to describe the user experience in the system design much clearer.
	- Option 1: Don’t Wait for Anything
		- If the synchronicity scope of the API is up to step 1, “Click the checkout button,” the user and the browser client will not wait for steps 2 to 3. The end-user will likely receive a message saying, “We are processing your order, and you will receive a notification when your payment is charged and the item is shipped out.” While the system is processing, if the payment charge and shipment are successful, the user will get a notification.
		- The advantage is the user doesn’t have to wait for the payment processor to finish before placing the order. It has a better perceived latency. However, the disadvantage is a poorer user experience if the payment processor fails and the user has to come back and try to place the order again. The failure doesn’t even have to be a system failure, it could be that the user’s payment method got declined.
	- Option 2: Wait for Payment Processor
		- If the API synchronicity scope is up to step 2, the end-user will receive a message once the payment is successful saying, “We have successfully charged your payment, and are in the process of shipping your item.” If the payment fails, the user will receive, “We can not charge your payment, please try again.” 
		- The advantage of this approach is the quick feedback loop of payment failure, and the user can change their payment method right away.
- Reasons for Asynchronous Processing
	- The main idea for asynchronous processing is you don’t want the end-user to wait for your task to complete because waiting for the job to complete would be a bad user experience. So, in an interview, you should justify why asynchronous processing would improve the end-user experience.
- The Nature of the Job is Asynchronous
	- Sometimes the scope of the system design interview problem does not immediately involve an end-user. For example, in a web crawler design, a list of URLs is already prepared for you to be processed, so no end users are waiting for the crawling process to finish. For a log search problem, you might already have a bunch of logs to process where the clients who generate the logs aren’t part of the scope of the problem.
	- Another example would be applications like chat and email. Once the end-user has successfully sent a chat or email, the end-user shouldn’t have to wait for the recipient to receive the message before letting the sender know.
	- However, sometimes you will get trending topics for trending tweets questions where an end-user generates the data. In this case, a typical solution is to use some sort of queue, and the request to insert into the queue is synchronous, and everything post queue insertion is asynchronous. This architecture means that if the request fails to insert into the queue, the user will get a message saying, “Sorry you’re unable to tweet now, please try again.”
- The Processing Time is Indeterministic
	- It isn’t clear how long the job is going to take for some jobs, and it’s usually better to tell the end-user to wait for a response. For example, when you request a ride to Uber, once the request is in the processing queue, you’re told to wait for your ride because the system isn’t sure how long it will take to match the ride. The user experience is because the processing of matching rider and driver is likely asynchronous.
- The Processing Time is Long-Running
	- If the processing time is long-running, you may not want the user to wait for a response until the system completes the job. For example, when you place an order on Amazon, it takes two days to receive it. You don’t want the browser to spin for two days until the item arrives at your door. Another example is a system that transcodes movies, which can take a long time. You don’t want the user who uploaded the movie to wait for an hour before the movie finishes transcoding.
- Improve Perceived Latency
	- As discussed in the e-commerce checkout platform, if the user doesn’t have to wait for the payment, the checkout will be faster than if you have to wait for some system to complete. However, it does come at the cost of fixing some errors if the system is unable to process, whereas if it was synchronous, the user could immediately fix the issue. However, you need to be careful here because this can be an anti-pattern to reduce the latency but incur a much worse user experience downstream.

- Batch Processing
	- Purpose
		- Batch processing is a form of asynchronous processing. In batch processing, the system processes a large amount of data periodically to generate output to let clients consume later. Here are some use cases for batch processing:
			- Run payroll, billing, and accounting for the company
			- Generate reverse index for documents
			- Generate word count for documents
			- Distributed sorting
		- When talking about batch processing, most people will think about MapReduce. It doesn’t have to be. Batch processing on a high-level means grabbing some data sources periodically, applying custom business logic, and creating an output to be consumed by another consumer. You can write custom code for each process. However, since many big data applications use MapReduce, it’s worth knowing an example of how MapReduce works if the interviewer asks you to provide details about your algorithm in your interview.
